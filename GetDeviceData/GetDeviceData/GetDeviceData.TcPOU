<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="GetDeviceData" Id="{bbbb3437-c728-49f1-b8eb-fac3c161592d}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'no_explicit_call'}
{attribute 'conditionalshow_all_locals'}
FUNCTION_BLOCK GetDeviceData EXTENDS ZCore.Object IMPLEMENTS ZCore.IUnmanagedObject
VAR_OUTPUT
  NameArray : ARRAY[0..Parameter.MaxDeviceToBeFound] OF ZCore.ZString;
  NetIdArray : ARRAY[0..Parameter.MaxDeviceToBeFound] OF Tc2_System.T_AmsNetID;
END_VAR
VAR
  _amsNetId : Tc2_System.T_AmsNetID;
  _ethercatMasterCount : UINT;
  _step : ZCore.Step(GetDeviceDataSteps.Begin, GetDeviceDataSteps.End);
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="Cyclic" Id="{2267b843-f919-45ab-a87e-d7470b57bd04}">
      <Declaration><![CDATA[/// The cyclic method should be run in any PLC-cycle. If the object has no work to do, we will simply
/// RETURN here. If an action has been started, this cyclic method takes care of all the work to do.
METHOD Cyclic
VAR_INST
  itIndex : UINT;
  ethercatMasters : UINT;
  indexArray : ARRAY[0..Parameter.MaxDeviceToBeFound] OF UINT;

  getDeviceType : Tc2_IoFunctions.IOF_GetDeviceType;
  getDeviceName : Tc2_IoFunctions.IOF_GetDeviceName;
  getDeviceNetIds : Tc2_IoFunctions.IOF_GetDeviceNetId;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE _step.Index OF
  GetDeviceDataSteps.Begin:
    IF Busy
    THEN
      _ethercatMasterCount := 0;
      _step.SetNext(GetDeviceDataSteps.FetchDeviceTypes);
    END_IF
  
  GetDeviceDataSteps.FetchDeviceTypes:
    IF _step.OnEntry()
    THEN
      getDeviceType(START:=FALSE);
      getDeviceType(START:=TRUE, NETID:=_amsNetId, DEVICEID:=ItIndex, TMOUT:=T#2S);
    END_IF
    
    getDeviceType(START:=FALSE);
    IF getDeviceType.ERR // no valid device found
    THEN
      IF ItIndex > Parameter.MaxDevicesSearchCount 
      THEN
        _step.SetNext(GetDeviceDataSteps.ResetId1);
      ELSE
        _step.SetNext(GetDeviceDataSteps.FetchDeviceTypes);
      END_IF
      
      itIndex := itIndex + 1;
    ELSIF NOT getDeviceType.BUSY
    THEN
      IF getDeviceType.IODeviceType = Tc2_IoFunctions.IODEVICETYPE_ETHERCAT
      THEN
        IndexArray[_ethercatMasterCount] := itIndex;
        _ethercatMasterCount := _ethercatMasterCount + 1;
        itIndex := itIndex + 1;
        _step.SetNext(GetDeviceDataSteps.ResetId1);
      END_IF
    END_IF

  GetDeviceDataSteps.ResetId1:
    itIndex := 0;
    _step.SetNext(GetDeviceDataSteps.GetDeviceNames);  
    
  GetDeviceDataSteps.GetDeviceNames:
    IF _step.OnEntry()
    THEN
      getDeviceName(START:=FALSE);
      getDeviceName(START:=TRUE, NETID:=_amsNetId, DEVICEID:=IndexArray[ItIndex], TMOUT:=T#2S);
    END_IF  
    
    getDeviceName();
    IF getDeviceName.ERR
    THEN
      Abort('Name could not be fetched!');
    ELSIF NOT getDeviceName.BUSY
    THEN
      NameArray[itIndex] := getDeviceName.DEVICENAME;
      itIndex := itIndex + 1;
      IF IndexArray[itIndex] <> 0
      THEN
        _step.SetNext(GetDeviceDataSteps.GetDeviceNames);
      ELSE
        _step.SetNext(GetDeviceDataSteps.ResetId2);
      END_IF
    END_IF
    
  GetDeviceDataSteps.ResetId2:
    itIndex := 0;
    _step.SetNext(GetDeviceDataSteps.GetDeviceNetIds);  
    
  GetDeviceDataSteps.GetDeviceNetIds:
    IF _step.OnEntry()
    THEN
      getDeviceNetIds(START:=FALSE);
      getDeviceNetIds(START:=TRUE, NETID:=_amsNetId, DEVICEID:=IndexArray[itIndex], TMOUT:=T#2S);
    END_IF  
    
    getDeviceNetIds();
    IF getDeviceNetIds.ERR
    THEN
      Abort('Name could not be fetched!');
    ELSIF NOT getDeviceNetIds.BUSY
    THEN
      NetIdArray[itIndex] := getDeviceNetIds.DeviceNetId;
      itIndex := itIndex + 1;
      IF IndexArray[itIndex] = 0
      THEN
        SetBusy(FALSE);
        _step.SetNext(GetDeviceDataSteps.End);
      END_IF
    END_IF      
  
  GetDeviceDataSteps.End:
    RETURN;
    
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="DeviceNamesAsync" Id="{13141ac0-b5ae-431f-95b4-bf53b0233b7e}">
      <Declaration><![CDATA[/// Starts reading of all available Ethercat-Master Device names
/// Just wait until Busy property of this object returns FALSE -> then fetch all Ethercat Master names from
/// the Array in VAR_INPUT of this object
METHOD DeviceNamesAsync
VAR_INPUT
  amsNetId : Tc2_System.T_AmsNetID; //< AMS-Netid of the IPC on which the device names should be fetched
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[SetBusy(TRUE);
_amsNetId := amsNetId;
_step.SetNext(GetDeviceDataSteps.Begin);]]></ST>
      </Implementation>
    </Method>
    <Property Name="EthercatMasterCount" Id="{1d505375-1582-4f78-a165-b684fe281a6d}">
      <Declaration><![CDATA[/// Returns the actual found Ethercat Master count -> Needed to iterate through the VAR_INPUT Arrays of AMSNet-IDs and
/// Ethercat Master Device names.
PROPERTY EthercatMasterCount : UINT]]></Declaration>
      <Get Name="Get" Id="{de855259-9a12-43d0-803f-73205d170aaf}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[EthercatMasterCount := _ethercatMasterCount;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="FB_init" Id="{755219fb-0948-4ab3-9f08-dc3591e71935}">
      <Declaration><![CDATA[/// Sets the object to Idle-State becuse no booting phase is needed here!
METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SetIdle();]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>